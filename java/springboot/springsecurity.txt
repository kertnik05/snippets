******************************************************************************
Springboot security basics
******************************************************************************
Dispacher Servelet - Where all request go in, and this delegates to another controller

Filters  

Delegating filter poxy

Filter Chain proxy
    - One per login type (For example: google or facebook)
    - Filter Chains: Authentication, Authorization,
    - Filter Chaings: 

Principal - objects that represent user, device, or application
    - Authorities - One Pricipal can have multiple authorities called roles
    - Authentication - populated by princial and authorities 
    - security context - populated by Authentication
    - http session - populated by security context

Adding to POM
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

The user will be the username and password will be generated in console

Scenario: User login
SecurityContext Persistence Filter 
    - security context filter
    - sc->security context holder
Logout filter
Authentication Filter
    - AuthenticationManager takes Authentication obj 
        - https://docs.spring.io/spring-security/site/docs/4.2.15.RELEASE/apidocs/org/springframework/security/authentication/AuthenticationManager.html
        - https://stackoverflow.com/questions/9787409/what-is-the-default-authenticationmanager-in-spring-security-how-does-it-authen
        - Creates Authentication request
            - Authenticated: False
            - username
            - password
            - Authorities
        - Sends this Request to Authentication Provider - does the authentication which delegates (loadbyusername) to userdetail service  and returns the userdetails to authentication provider 
            - OpenIDAuthenticationProvider
            - DapAuthenticatinProvider
            - LDAPAuthenticatinProvider
        Returns Authenticated Principal
        - If authentication is succesful,  it populates the security context which is populated with authentication object such as principal and authorities

Remember me Filter
    - is there a Remember me cookie
Exception Translation Filter
Filter Secutity Interceptor 
Resource

Scenario: User hit a securred resource without logging
SecurityContext Persistence Filter 
    - security context filter
    - sc->security context holder
Logout filter
Authentication Filter
Remember me Filter
    - is there a Remember me cookie
Exception Translation Filter - > forward to Authentication Entry point
Filter Secutity Interceptor - is theses a securred resouce - AuthenticationException 
Resource

Scenario: User hit a securred resource and is login
SecurityContext Persistence Filter 
    - security context filter
    - sc->security context holder - populate the securitycontext 
Logout filter
Authentication Filter
Remember me Filter
    - is there a Remember me cookie
Exception Translation Filter - > translate error
Filter Secutity Interceptor - is theses a securred resouce - AuthenticationException 
    - Access Decession manager
        - Access Denied Exception
Resource

Eclipse quick shortcut commands list - https://dzone.com/articles/effective-eclipse-shortcut-key
sping-boot-autoconfigure -> MATA-INF -> spring.factories -> org.springframework.boot.autoconfigure.security
- CTRL+SHIFT+T
- 1. search for SecurityAutoConfiguration

@Configuration
@ConditionalOnClass({ AuthenticationManager.class,
		GlobalAuthenticationConfigurerAdapter.class })
@EnableConfigurationProperties
@Import({ SpringBootWebSecurityConfiguration.class,
		AuthenticationManagerConfiguration.class,
		BootGlobalAuthenticationConfiguration.class })
public class SecurityAutoConfiguration {

	@Bean
	@ConditionalOnMissingBean
	public AuthenticationEventPublisher authenticationEventPublisher(
			ApplicationEventPublisher publisher) {
		return new DefaultAuthenticationEventPublisher(publisher);
	}

	@Bean
	@ConditionalOnMissingBean
	public SecurityProperties securityProperties() {
		return new SecurityProperties();
	}

}

- 2. search for SpringBootWebSecurityConfiguration
    - WebSecurityConfiguration - if mssing, SpringBootWebSecurityConfiguration os applied
- 3. search for WebSecurityConfiguration ( org.springframework.security.config.annotation.web.configuration)
    - setFilterChainProxySecurityConfigurer
- 4. search for SecurityFilterAutoConfiguration
    - DelegatingFilterProxyRegistrationBean - no need to configure 
- 5. UserDetailsServiceAutoConfiguration - creates a username and password
    - @ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class })
public class UserDetailsServiceAutoConfiguration {}

- 3. search for EnableWebSecurity
- 4. search for WebSecurityConfiguration
- search for WebSecurityConfigurerAdapter
- search for SecurityAutoConfiguration
- search for SpringBootWebSecurityConfiguration
- search for EnableWebSecurity
- search for WebSecurityConfiguration

- AbstractSecurityWebApplicationInitializer

You can see all the filter 
DelegatingFilterProxy
- https://www.marcobehler.com/guides/spring-security#_filterchain_security_configuration_dsl
You can see these in maven dependency
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\

******************************************************************************
Extend WebSecurityConfigurerAdapter
******************************************************************************

1 . Extend WebSecurityConfigurerAdapter, as per SpringBootWebSecurityConfiguration
    @EnableWebSecurity
    @EnableGlobalMethodSecurity(securedEnabled = true)
    @Order(2)
    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { 

        //copy from WebSecurityConfigurerAdapter and do your override
        protected void configure(HttpSecurity http) throws Exception {
            logger.debug("Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).");

            http
                .authorizeRequests()
                    .anyRequest().authenticated()
                    .and()
                .formLogin().and()
                .httpBasic();
        }
        //If you check the network tab of your browser in response headers, you will see WWW-Authenticate: Basic ream="Realm" 
        //This means you are using basic authentication 
        //If succesful, it will send authorization header which is bse64 endoded. If you decode it, it will show your username and password 
        protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequest()
                .antMatchers("/<myloginurl>","<anotherurl>).permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().loginPage("<myloginurl>").defaultSuccessUrl("/<customurl>", true)
                .and().csrf().disable();

        }

        //Ignore security for static files
        @Override
        public void configure(Websecurity web) throws Exception {
            web.ignorig().antMatchers("/css/**","/webjars/**");
        }
        

    }

    DelegatingFilterProxyRegistrationBean
        - DefaultSecurityFilter
        - Arraylist<E>
        - WebAsyncManagerIntegrationFilter
        - SecurityContextPersistenceFilter
        - HeaderWriterFilter
        - CsrfFilter
        - LogoutFIlter
        - BasicAuthenticationFilter
        - RequestCacheAwareFilter
        - SecurityContextHolderAwareRequestFilter
        - AnonymouseAuthenticationFilter
        - SessionManagentFilter
        - ExceptionTranslationFilter
        - FilterSecurityInterceptor
    FilterChainProxy 
        - 
     @Configuration
     @Order(1)
     public class AdminSecurityConfiguration extends WebSecurityConfigurerAdapter {
            @Override
            protected void configure(AuthenticationManagerBuilder auth) throws Exception
            {
                auth.jdbcAuthentication().dataSource(datasource)
                    .usersByUsernameQuery("SELECT ID_USER, PASSWORD, ACTIVE FROM USERS WHERE ID_USER = ?;")
                    .authoritiesByUsernameQuery("SELECT ID_USER, ID_ROLE FROM USER_ROLES WHERE ID_USER = ?");
            }

            @Bean
            public DigestAuthenticationEntryPoint digestEntryPoint ()
            {
                DigestAuthenticationEntryPoint digestAuthenticationEntryPoint = new DigestAuthenticationEntryPoint();
                digestAuthenticationEntryPoint.setKey("<yourkey>");
                digestAuthenticationEntryPoint.setRealmName("<yourcustomrealname>");
                return digestAuthenticationEntryPoint;
            }

            @Bean
            public PasswordEncoder passwordEncoder(){
                return NoOpPasswordEncoder.getInstance();
            }

            @Override
            @Bean
            public UserDetailsService userDetailsServiceBean() {
                return super.userDetailsServiceBean();
            }

            @Bean
            public DigestAuthenticationFilter getDigestAuthFilter(DigestAuthenticationEntryPoint entryPoint,
                                                            UserDetailsService userDetailsService) throws Exception {
                DigestAuthenticationFilter filter = new DigestAuthenticationFilter();
                filter.setUserDetailsService(userDetailsServiceBean());
                filter.setAuthenticationEntryPoint(digestEntryPoint());
                return filter;
            }
            }

            @Override
            protected void configure(HttpSecurity http) throws Exception {
                http.headers().disable().antMatcher("/admin/**").
                addFilter(getDigestAuthFilter()).exceptionHandling()
                .authenticationEntryPoint(digestEntryPoint())
                .and().authorizeRequests().antMatchers("/admin/**").hasRole("ADMIN");
            }
      }

      //When using digest, see the network response authorization 

<input type="hidden" th:name="${_csrf.parameterName}" th:value="${}"_csrf.token />

******************************************************************************
Enabling Https 
******************************************************************************

keytool - create jks
symmetric encryption
ssl handshake steps 
Client send a request to Server 
Server will respond with public key 
Client recieves the public key and sends it back the data to server with session key and public key 
Server will decrypt the data using the private key and sends back a response with session key and public key 
Client will decrypt using the session key  

        - Property based
            - https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#web-properties
            - https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#server-properties
        - keytool -genkey -keyalg RSA alias <youralia> -keystore keystore.jsk -storepass <yourpassword> -validity 4000 -keysize <2048|4096>
            - you can add this to your application.properties
                server:
                port: 8080
                ssl:
                    key-store: classpath:keystore.jks 
                    key-store-password: <password>
                    key-store-type: JKS 
                    key-alias: <youralias>
                    key-password: <password>
            - http --verify=no https:localhost:8080/api/greeting
            - http https:localhost:8080/api/rooms Accept:application.xml


            //Inside Application.java - https://www.programcreek.com/java-api-examples/index.php?api=org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory
            @Bean
            public ServletWebServerFactory servletContainer() throws Exception {
                TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
                    @Override
                    protected void postProcessContext(Context context) {
                        SecurityConstraint securityConstraint = new SecurityConstraint();
                        securityConstraint.setUserConstraint("CONFIDENTIAL");
                        SecurityCollection collection = new SecurityCollection();
                        collection.addPattern("/*");
                        securityConstraint.addCollection(collection);
                        context.addConstraint(securityConstraint);
                    }
                tomcat.addAdditionalTomcatConnectors(redirectConnector());
	            return tomcat;
            }
            //https://docs.spring.io/spring-boot/docs/1.0.x/reference/html/howto-embedded-servlet-containers.html
            private Connector getConnector() {
                Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
                connector.setScheme("http");
                connector.setPort(8080);
                connector.setRedirectPort(8443);
                return connector;
            }
******************************************************************************
Spring Cloud Vault
******************************************************************************

https://www.vaultproject.io/downloads
But I have given you the downloaded zip file to you in micro-lab-docs folder. Extract it.
https://www.vaultproject.io/docs/configuration

vault
vault.hcl 
    storage "file" {
        path = "./vault-data"
    }

    listener "tcp" {
        address = "127.0.0.1:8200"
        tls_disable=1
    }

    disable_mlock=true

create a folder add vault app, and vault.hcl inside: then run the command, vault server -config ./vault.hcl
Our Vault server now is running, but since this is its first run, we need to initialize it.

Our Vault server now is running, but since this is its first run, we need to initialize it.
run command:
Set VAULT_ADDR=http://localhost:8200
vault operator init

After issuing the above command, we should see a message like this:
Unseal Key 1: randomstring
Unseal Key 2: randomstring
Unseal Key 3: randomstring
Unseal Key 4: randomstring
Unseal Key 5: randomstring

The five first lines are the master key shares that we will later use to unseal Vault's storage. Please note that Vault only displays the master key shares will during initialization – and never more. Take note and store them safely or we'll lose access to our secrets upon server restart!

Now execute the below command:

Set VAULT_TOKEN= <root token value>

Let's see our server status now that we have initialized it, with the following command:

Execute the following command:

 vault status 

you should see vault_seal.png

 Observe that the vault is sealed

Observe the unseal progress: “0/3” means that Vault needs three shares, but got none so far. Let's move ahead and provide it with our shares.

We now unseal Vault so we can start using its secret services. We need to provide any three of the five key shares in order to complete the unseal process:

vault operator unseal <key share 1 value>
vault operator unseal <key share 2 value>
vault operator unseal <key share 3 value>


After executing all the 3 commands, value should be unsealed 

Now You need to enable the KV secrets engine at path secret

Execute the following commands

vault secrets enable -path=secret/ kv

Now put a key value pair into vault using below command:

vault kv put secret/myapp keystorepassword=tomcat 


Till now, we have started valut and stored keystorepassword=tomcat in vault

Now we want out spring boot app to read secrets from valut.

Open pom.xml and complete 
Now create a file with name bootstrap.yml under src/main/resources and configure it will following:

spring:
  application:
    name: myapp
  cloud:
    vault:
      host: localhost
      port: 8200
      scheme: http
     # authentication: token
      token: s.yZPi3ogu1BI585ZHw9Dqh2EZ
      
Now Replace the key token in bootstrap.yml with the root token which you got when you initialized vault


In application.yml replace the value of server.ssl.key-store-password with ${keystorepassword}

 Now start your application and give a request to http://localhost:8080/hello?name=siva

Everything should work fine and you should be redirected to login page which uses https

This means that the keystore password is retrieved from the vault successfully.

******************************************************************************
Remember Me
******************************************************************************

We want to enable remember me functionality for my app.
Open login.html and uncomment the check box code for remember me check box


http
    .authorizeRequests()
    .antMatchers("/register","/mylogin","/h2/console/**).permitAll()
        .anyRequest().authenticated()
        .and()
    .formLogin().loinPage("/mylogin").defaultSuccessUrl("/hello",true).and().csrf().disable().rememberMe().key("mykey");

    http.headers().frameOptions().disable();

Now, give a request to http://localhost:8080/hello?name=Siva

You should be redirected to login page and now you should see remember me check box.

Press F12 on your firefox browser and click on storage tab to see cookies. You should see only jsessionid cookie.

Now submit your credentials and login.
After logging in, you should see remember-me cookie also.

rememberme: <randombase64> 
If you decode this base 64: <username>:expirationtime:md5Hex(username:expirationtime:password:key)

This cookie will be red by the server. It will automatically unhashed and check if the hashed has the same username and password from database 


